<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>Maki4</title><subtitle>这是通过Chirpy主题配置而成的</subtitle> <updated>2022-10-07T07:02:44+00:00</updated> <author> <name>Maki4</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 Maki4 </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>堆</title><link href="/posts/%E5%A0%86/" rel="alternate" type="text/html" title="堆" /><published>2022-04-25T00:00:00+00:00</published> <updated>2022-05-05T05:13:00+00:00</updated> <id>/posts/%E5%A0%86/</id> <content src="/posts/%E5%A0%86/" /> <author> <name>Maki4</name> </author> <category term="笔记" /> <summary> 堆 堆是一个完全二叉树 根节点为最小值，并且每个根节点都小于等于左右节点。 数组存储堆 第一步是在heap的末尾插入x 并且将x往上移 #include&amp;lt;iostream&amp;gt; #include&amp;lt;algorithm&amp;gt; using namespace std; const int N = 100010; int h[N],len; int n,m; void down(int u) { int t = u; if(u * 2 &amp;lt;= len &amp;amp;&amp;amp; h[u * 2] &amp;lt; h[t]) t = u * 2; if(u * 2 + 1 &amp;lt;= len &amp;amp;&amp;amp; h[u * 2 + 1] &amp;lt; h[t]) t = u * 2 + 1; if(u != t) { ... </summary> </entry> <entry><title>Trie/并查集</title><link href="/posts/Trie%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="alternate" type="text/html" title="Trie/并查集" /><published>2022-04-18T00:00:00+00:00</published> <updated>2022-04-18T00:00:00+00:00</updated> <id>/posts/Trie%E5%B9%B6%E6%9F%A5%E9%9B%86/</id> <content src="/posts/Trie%E5%B9%B6%E6%9F%A5%E9%9B%86/" /> <author> <name>Maki4</name> </author> <category term="笔记" /> <summary> 插入操作 void insert (char str[])//插入字符串 { int p = 0;//p是根节点 for(int i = 0; str[i]; i ++ ) { int u = str[i] - 'a' ;//u代表让字符串转化为编号， if(!son[p][u]) son[p][u] = ++ idx; //如果不存在 就创建 p = son[p][u]; } cnt[p] ++ ; } 查找操作 int query(char str []) { int p = 0; for(int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if(!son[p][u]) retu... </summary> </entry> <entry><title>栈与队列</title><link href="/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" rel="alternate" type="text/html" title="栈与队列" /><published>2022-04-07T00:00:00+00:00</published> <updated>2022-04-07T00:00:00+00:00</updated> <id>/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id> <content src="/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" /> <author> <name>Maki4</name> </author> <category term="笔记" /> <summary> 栈是一种特殊容器 数据元素是按照线性排列 也可定义首 末元素 栈虽然支持插入和删除操作 但操作范围仅限栈的某一特定端 故只能从某一端插入 也只能从某一段删除 禁止操作的另一端 称为盲端。 支持的操作接口 栈操作实例 stack 模板类 template &amp;lt;typename T&amp;gt; class Stack : public Vector&amp;lt;T&amp;gt;{ public : // size() empty()接口 其他开放接口 均可直接沿用 void push(T const &amp;amp;e) { insert(size(), e);//入栈 } T pop () { return remove(size() - 1); } T&amp;amp; top () { (*this)[size() - 1];//取顶 : 直接返回向量的末元素 } ... </summary> </entry> <entry><title>链表(acwing)</title><link href="/posts/%E9%93%BE%E8%A1%A8/" rel="alternate" type="text/html" title="链表(acwing)" /><published>2022-03-30T00:00:00+00:00</published> <updated>2022-03-30T00:00:00+00:00</updated> <id>/posts/%E9%93%BE%E8%A1%A8/</id> <content src="/posts/%E9%93%BE%E8%A1%A8/" /> <author> <name>Maki4</name> </author> <category term="笔记" /> <summary> 单链表的实现(用数组实现) #include&amp;lt;iostream&amp;gt; using namespace std; const int N[100010] int head ,e[N],ne[N],idx;//head 是头结点的下标 e[i]表示节点i的值 ne[i] 表示节点i的next指针 idx是当前用到的点 void init()//初始化 { head = -1; idx = 0; } 插入 void add_head(int x) { e[idx] = x;//将x的值 插入idx当中 ne[idx] = head;//当前要插入的next指针 指向head所指向的节点 head = idx;//将head 指向idx idx ++; } void add (int k ,int x)//将x插入... </summary> </entry> <entry><title>STL学习</title><link href="/posts/c++STL%E5%BA%93/" rel="alternate" type="text/html" title="STL学习" /><published>2022-03-29T00:00:00+00:00</published> <updated>2022-03-30T01:18:00+00:00</updated> <id>/posts/c++STL%E5%BA%93/</id> <content src="/posts/c++STL%E5%BA%93/" /> <author> <name>Maki4</name> </author> <category term="笔记" /> <summary> c++stl库 vector ： #include &amp;lt;vector&amp;gt; //头文件 vector&amp;lt;int&amp;gt; a; //相当于一个长度动态变化的int数组 vector&amp;lt;int&amp;gt; b[233]; //相当于第一维长233，第二位长度动态变化的int数组 struct rec{…}; vector&amp;lt;rec&amp;gt; c; //自定义的结构体类型也可以保存在vector中 队列： #include&amp;lt;queue&amp;gt;//头文件 #include&amp;lt;iostream&amp;gt; using namespace std; int main() { queue&amp;lt;int&amp;gt;q;//队列的定义 先进先出 q.push(1);//在队头插入一个元素 q.pop();//弹出队头元素 q.... </summary> </entry> </feed>
