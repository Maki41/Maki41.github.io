[ { "title": "堆", "url": "/posts/%E5%A0%86/", "categories": "笔记", "tags": "数据结构", "date": "2022-04-25 00:00:00 +0000", "snippet": "堆堆是一个完全二叉树 根节点为最小值，并且每个根节点都小于等于左右节点。数组存储堆 第一步是在heap的末尾插入x 并且将x往上移#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 100010;int h[N],len;int n,m;void down(int u){ int t = u; if(u * 2 &lt;= len &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2; if(u * 2 + 1 &lt;= len &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1; if(u != t) { swap(h[u],h[t]); down(t); }}void(int u){ while(u / 2 &amp;&amp; h[u / 2] &gt; h[u]) swap(h[u],h[u / 2]); u = u / 2;}int main(){ scanf(\"%d%d\",&amp;n ,&amp;m); for(int i = 1; i &lt;= n; i ++) scanf(\"%d\",&amp;h[i]); len = n; for(int i = n / 2; i ; i --) down(i); while(m --) { printf(\"%d \",h[1]); h[1] = h[len]; len --; down(1); } return 0;}" }, { "title": "Trie/并查集", "url": "/posts/Trie%E5%B9%B6%E6%9F%A5%E9%9B%86/", "categories": "笔记", "tags": "数据结构", "date": "2022-04-18 00:00:00 +0000", "snippet": "插入操作void insert (char str[])//插入字符串{ int p = 0;//p是根节点 for(int i = 0; str[i]; i ++ ) { int u = str[i] - 'a' ;//u代表让字符串转化为编号， if(!son[p][u]) son[p][u] = ++ idx; //如果不存在 就创建 p = son[p][u]; } cnt[p] ++ ;}查找操作int query(char str []){ int p = 0; for(int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if(!son[p][u]) return 0; p = son[p][u]; } return cnt[p];并查集 例题 #include&lt;iostream&gt;using namespace std;const int N = 100010;int a,b;int n , m;int p[N];int find(int x){ if(p[x] != x) p[x] = find(p[x]);//如果x不是根节点，直接让x的父节点指向祖宗节点。路径压缩 return p[x];}int main(){ scanf(\"%d%d\",&amp;n,&amp;m); for(int i = 1;i &lt; n; i ++) p[i] = i; while(m --) { char op[2]; scanf(\"%s%d%d\",op,&amp;a,&amp;b); if(op[0] == 'M') p[find(a)] = find(b);//让集合b成为集合a的祖宗节点 else { if(find(a) == find(b)) puts(\"Yes\"); else puts(\"No\"); } } return 0;}" }, { "title": "栈与队列", "url": "/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/", "categories": "笔记", "tags": "数据结构", "date": "2022-04-07 00:00:00 +0000", "snippet": " 栈是一种特殊容器 数据元素是按照线性排列 也可定义首 末元素 栈虽然支持插入和删除操作 但操作范围仅限栈的某一特定端 故只能从某一端插入 也只能从某一段删除 禁止操作的另一端 称为盲端。 支持的操作接口 栈操作实例stack 模板类template &lt;typename T&gt; class Stack : public Vector&lt;T&gt;{public : // size() empty()接口 其他开放接口 均可直接沿用void push(T const &amp;e){\tinsert(size(), e);//入栈}T pop (){\treturn remove(size() - 1);}\tT&amp; top (){\t(*this)[size() - 1];//取顶 : 直接返回向量的末元素}}#include&lt;iostream&gt;using namespace std;const int N = 100010;int stk[N] , tt , n;int main(){ cin &gt;&gt; n; for(int i = 0; i &lt; n; i ++) { int x; cin &gt;&gt; x; while (tt &amp;&amp; stk[tt] &gt;= x) tt --; if(tt) cout &lt;&lt; stk[tt] &lt;&lt; \" \"; else cout &lt;&lt; -1 &lt;&lt; \" \"; stk[ ++ tt] = x; } return 0;}在栈中构造一个单调栈 如果在数组当中 ax &gt; ay 也就是x的值大于y但是x在y的左边 在枚举过程中就不会枚举到 从而形成单调" }, { "title": "链表(acwing)", "url": "/posts/%E9%93%BE%E8%A1%A8/", "categories": "笔记", "tags": "数据结构", "date": "2022-03-30 00:00:00 +0000", "snippet": "单链表的实现(用数组实现)#include&lt;iostream&gt;using namespace std;const int N[100010]int head ,e[N],ne[N],idx;//head 是头结点的下标 e[i]表示节点i的值 ne[i] 表示节点i的next指针 idx是当前用到的点void init()//初始化{ head = -1; idx = 0;}插入void add_head(int x){ e[idx] = x;//将x的值 插入idx当中 ne[idx] = head;//当前要插入的next指针 指向head所指向的节点 head = idx;//将head 指向idx idx ++;}void add (int k ,int x)//将x插入k的后面{ e[idx] = x ne[idx] = ne[k]; ne[k] = idx; idx++;}void remove(int k) //将下标是k的点后面的点删掉{ ne[k] = ne[ne[k]];//将k的next指针直接指向要删除的点的下一个节点}双链表int e[N] , l[N] , r[N] , idx ;//l[N]表示每个点左边的点 r[N]同理//初始化void init(){ //0表示左端点 1表示右端点 r[0] = 1; l[1] = 0; idx = 2;}void add(int k,int x)//在下标是k的点的右边，插入x k表示被插入点 x表示新节点 //如果要在左边插入 把k换为l[k]{ e[idx] = x; r[idx] = r[k]; //新节点的右边的指针 指向被插入点的右边 l[idx] = k;//新节点的左边的指针指向被插入点 l[r[k]]= idx;//被插入点的右边指向新节点 r[k] = idx;}## 删除操作//删除第k个点void remove (int k){ r[l[k]] = r[k];//k这个点的左边指针 直接指向下一个点 l[r[k]] = l[k];}" }, { "title": "STL学习", "url": "/posts/c++STL%E5%BA%93/", "categories": "笔记", "tags": "数据结构", "date": "2022-03-29 00:00:00 +0000", "snippet": "c++stl库vector ：#include &lt;vector&gt; \t//头文件\t\tvector&lt;int&gt; a;\t\t//相当于一个长度动态变化的int数组\t\tvector&lt;int&gt; b[233];\t//相当于第一维长233，第二位长度动态变化的int数组\t\tstruct rec{…};\t\tvector&lt;rec&gt; c;\t\t//自定义的结构体类型也可以保存在vector中队列：#include&lt;queue&gt;//头文件#include&lt;iostream&gt;using namespace std;int main(){ queue&lt;int&gt;q;//队列的定义 先进先出 q.push(1);//在队头插入一个元素 q.pop();//弹出队头元素 q.front();//返回队头 q.back();//返回队尾 proprity_queue&lt;int&gt;q //大根堆 先弹出最大值 proprity_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;b;//小根堆 先弹出最小值 \t//优先队列大根堆需要重载小于号。小根堆相反 q = queue&lt;int&gt;();//队列初始化 }栈#include&lt;stack&gt;//头文件//特点 先进后出stack&lt;int&gt;s;//栈的声明s.push(1);//在栈头插入元素s.top();//返回栈头元素s.pop();//删除最后一个插入元素双端队列#include&lt;deque&gt; //头文件a.deque&lt;int&gt;a;//声明a.begin/end()//返回deque的头/尾迭代器a.front/back()//队头/队尾元素a.push_back() //从队尾入队a.push_front() //从队头入队a.pop_back() //从队尾出队a.pop_front() //从队头出队a.clear() //清空队列a[0] //随机访问头文件set 头文件set主要包括set和multiset两个容器，分别是“有序集合”和“有序多重集合” set&lt;int&gt; s;//声明 元素不能重复mutiset&lt;int&gt;s//元素可以重复 struct rec{ \tint x,y;\tbool operator &lt; (const rec&amp; t) const\t{ return x &lt; t.x;\t}};\tset&lt;rec&gt;c;//重载小于号a.insert(x)//插入一个xa.find(x)//查找与x值相同的元素 s.lower_bound(x) //查找大于等于x的元素中最小的一个，并返回指向该元素的迭代器。注意是大于等于s.upper_bound(x) //查找大于x的元素中最小的一个，并返回指向该元素的迭代器。大于 s.erase(it)//从s中删除迭代器it指向的元素 s.count(x) //返回集合s中等于x的元素个数 Map map容器是一个键值对key-value的映射，其内部实现是一棵以key为关键码的红黑树。Map的key和value可以是任意类型，其中key必须定义小于号运算符。 #include&lt;map&gt;//map&lt;key_type, value_type&gt; name;例如：map&lt;long, long, bool&gt; vis; //size/empty/clear/begin/end均与set类似。 ```" } ]
