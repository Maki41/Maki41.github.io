---
layout: post
title: 链表刷题(acwing)
categories: [笔记]
tags: [数据结构]
toc: true
comments: true
typora-root-url: ../../maki41.github.io
math: false
mermaid: true
---

### 链表练习

###### 1

![image-20220405122315880](/assets/blog_res/2022-04-05-%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98.assets/image-20220405122315880.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> printListReversingly(ListNode* head) {
        vector <int> res;
        for(auto p = head ; p != 0; p = p -> next)//遍历链表
        {
            res.push_back(p -> val);//将val输出到每个值中
        }
        reverse(res.begin(),res.end());//反转链表
        return res;
        
    }
};
```



##### 2



![image-20220405170755464](/assets/blog_res/2022-04-05-%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98.assets/image-20220405170755464.png)





```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        node -> val = node -> next -> val;//将node下一个结点的值 覆盖到当前节点
        node -> next = node -> next -> next;//删除当前节点的下一个节点 直接将指针跳过
    }
};
```

##### 3

![image-20220405170820462](/assets/blog_res/2022-04-05-%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98.assets/image-20220405170820462.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplication(ListNode* head) {
        auto dummy = new ListNode(-1);
        dummy->next = head;
        auto p = dummy;
        while(p->next)//p的下一个值存在
        {
            auto q = p->next;
            while(q->next && p->next->val == q->next->val) //q点的下一个值与p的下一个值相同(检测有无相同元素)
            q = q->next;
            if(q == p->next)//证明p和q之间只有一个元素 不需要删除
            p = q;
            else
            p->next = q->next;
            
        }
            return dummy->next;
    }

};
```

##### 4

![image-20220406154036699](/assets/blog_res/2022-04-05-%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98.assets/image-20220406154036699.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* findKthToTail(ListNode* head, int k) {
        int n = 0;
        auto p = head;
        for(auto p = head; p != 0; p = p -> next) n ++;
        //遍历链表中有多少个节点
        if(k > n) return NULL;
        for(int i = 0 ; i < n - k ; i ++) p = p -> next;
        return p;
        
    }
};
```

